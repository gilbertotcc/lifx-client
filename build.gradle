import net.researchgate.release.cli.Executor

plugins {
  id 'java'
  id 'groovy'
  id 'maven'
  id 'jacoco'
  id 'checkstyle'
  id 'com.jfrog.bintray' version '1.8.4'
  id 'maven-publish'
  id 'com.adarshr.test-logger' version '1.6.0'
  id 'net.researchgate.release' version '2.8.0'
  id 'com.github.kt3k.coveralls' version '2.8.2'
  id "org.sonarqube" version "2.7"
}

sourceCompatibility = JavaVersion.VERSION_11
targetCompatibility = JavaVersion.VERSION_11

wrapper {
  gradleVersion = '5.1'
}

repositories {
  mavenCentral()
  mavenLocal()
}

dependencies {
  // RETROFIT
  compile 'com.squareup.retrofit2:retrofit:2.5.0'
  compile 'com.squareup.retrofit2:converter-jackson:2.5.0'

  // JACKSON
  compile 'com.fasterxml.jackson.core:jackson-core:2.9.9'
  compile 'com.fasterxml.jackson.core:jackson-databind:2.9.9'
  compile 'com.fasterxml.jackson.core:jackson-annotations:2.9.9'
  compile 'com.fasterxml.jackson.module:jackson-module-parameter-names:2.9.9'
  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8:2.9.9'
  compile 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.9.9'

  // COMMON
  annotationProcessor 'org.projectlombok:lombok:1.18.4'
  compileOnly 'org.projectlombok:lombok:1.18.4'
  compile 'io.vavr:vavr:0.10.0'
  compile 'org.slf4j:slf4j-api:1.7.25'
  compile 'org.apache.commons:commons-lang3:3.7'
  compile 'com.squareup.okhttp3:logging-interceptor:3.10.0'

  // LOGGING
  compile 'ch.qos.logback:logback-classic:1.+'

  // TEST
  testAnnotationProcessor 'org.projectlombok:lombok:1.18.4'
  testCompileOnly 'org.projectlombok:lombok:1.18.4'
  testImplementation 'org.junit.jupiter:junit-jupiter:5.5.2'
  testCompile 'com.tngtech.archunit:archunit-junit5-api:0.12.0'
  testRuntime 'com.tngtech.archunit:archunit-junit5-engine:0.12.0'
  testCompile 'org.skyscreamer:jsonassert:1.5.0'
  testCompile 'org.mockito:mockito-core:2.23.4'
  testCompile 'com.github.tomakehurst:wiremock:2.18.0'
  testCompile 'org.codehaus.groovy:groovy-all:2.4.15'
  testCompile 'org.spockframework:spock-core:1.2-groovy-2.4'
  testRuntime 'net.bytebuddy:byte-buddy:1.8.21'
}

jar {
  archiveBaseName = 'lifx-client'
}

ext {
  jacocoMergedReport = file("$buildDir/jacoco/mergeTest.exec")
}

task jacocoMergeTestReport(type: JacocoMerge) {
  executionData tasks.withType(Test)
  destinationFile = jacocoMergedReport
}

jacocoTestReport {
  dependsOn jacocoMergeTestReport
  executionData jacocoMergedReport
  reports {
    xml.enabled true
    csv.enabled false
    html.enabled true
    html.destination file("${buildDir}/reports/jacocoHtml")
  }
}

coveralls {
  jacocoReportPath 'build/reports/jacoco/test/jacocoTestReport.xml'
}

tasks.coveralls {
  dependsOn 'check'
}

task spockTest(type: Test, description: 'Runs tests written in Spock.', group: LifecycleBasePlugin.VERIFICATION_GROUP) {
  useJUnit()
}

check.dependsOn spockTest

test {
  useJUnitPlatform()
  // Exclude integration tests
  exclude '**/*IntegrationTest*'
}

test.finalizedBy jacocoTestReport

// CHECKSTYLE

checkstyleMain.source = "src/main/java"
checkstyleTest.source = "src/test/java"

// SONARQUBE

ext {
  isCIEnv = System.getenv('CI') != null
  isCIAndDevelopBranch = 'develop' == System.getenv('CIRCLE_BRANCH') ?: ''
  sonarHostUrl = 'https://sonarcloud.io'
  sonarLogin = System.getenv('SONAR_LOGIN')
  sonarProjectKey = 'gilbertotcc_lifx-client'
  sonarOrganization = 'gilbertotcc-github'
  testSources = 'src/test/groovy,src/test/java'
  jacocoMergedReport = file("$buildDir/jacoco/mergeTest.exec")
  generatedTestSourcesDir = 'generated-test-sources'
}

sonarqube {
  properties {
    property 'sonar.host.url', sonarHostUrl
    property 'sonar.projectKey', sonarProjectKey
    property 'sonar.organization', sonarOrganization
    property 'sonar.login', sonarLogin
    property 'sonar.jacoco.reportPath', "$buildDir/reports/jacoco/test/jacocoTestReport.xml"
    property 'sonar.tests', testSources
    property 'sonar.test.exclusions', "**/${generatedTestSourcesDir}/**/*.java"
  }
}

def sonarqubeTask = project.tasks["sonarqube"]

sonarqubeTask.enabled = isCIAndDevelopBranch

publishing {
  publications {
    maven(MavenPublication) {
      from components.java
    }
  }
}

release {
  preTagCommitMessage = '[Gradle Release Plugin] - pre tag commit [skip ci]: '
  newVersionCommitMessage = '[Gradle Release Plugin] - new version commit [skip ci]: '
}

afterReleaseBuild.dependsOn bintrayUpload

commitNewVersion {
  doLast {
    logger.info("Merging and pushing branch 'master' to 'develop' after release.")
    def executor = new Executor(project.logger)
    def workingDirectory = project.rootDir
    def toBranch = 'develop'
    executor.exec(['git', 'fetch'], directory: workingDirectory, errorPatterns: ['error: ', 'fatal: '])
    executor.exec(['git', 'checkout', toBranch], directory: workingDirectory, errorPatterns: ['error: ', 'fatal: '])
    executor.exec(['git', 'merge', '--no-ff', 'master'], directory: workingDirectory, errorPatterns: ['error: ', 'fatal: ', 'CONFLICT'])
    executor.exec(['git', 'push', '--porcelain', 'origin', 'develop'], directory: workingDirectory, errorMessage: "Failed to push to 'develop' branch after 'master' was merged.", errorPatterns: ['[rejected]', 'error: ', 'fatal: '])
    executor.exec(['git', 'checkout', 'master'], directory: workingDirectory, errorPatterns: ['error: ', 'fatal: '])
  }
}

bintray {
  user = System.getenv('BINTRAY_USERNAME')
  key = System.getenv('BINTRAY_API_KEY')
  publish = true
  publications = ['maven']
  pkg {
    repo = 'lifx'
    name = 'lifx-client'
    desc = 'Java client to consume LIFX HTTP API'
    licenses = ['BSD 2-Clause']
    websiteUrl = 'https://github.com/gilbertotcc/lifx-client'
    vcsUrl = 'https://github.com/gilbertotcc/lifx-client.git'
    githubRepo = 'gilbertotcc/lifx-client'
    githubReleaseNotesFile = 'README.md'
    issueTrackerUrl = 'https://github.com/gilbertotcc/lifx-client/issues'
  }
}
